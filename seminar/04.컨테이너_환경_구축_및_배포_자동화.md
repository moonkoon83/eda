# 04. 컨테이너 환경 구축 및 배포 자동화

기존 애플리케이션을 클라우드 네이티브 환경(Cloud-Native)에 맞게 전환하기 위한 첫 단계로, 컨테이너 기반의 빌드, 배포, 실행 환경을 구축하고 이를 자동화하는 과정을 진행했습니다.

## 1. 애플리케이션 컨테이너화 (Containerization)

애플리케이션을 어떤 환경에서든 동일하게 실행할 수 있도록 Docker 컨테이너 이미지로 패키징하는 작업을 수행했습니다.

### Dockerfile 작성

프로젝트 루트에 `Dockerfile`을 생성하여 컨테이너 이미지를 만드는 과정을 정의했습니다. 최종 이미지의 크기를 줄이고 빌드 효율성을 높이기 위해 **멀티-스테이지 빌드(Multi-stage Build)** 전략을 채택했습니다.

- **빌드 스테이지**: `gradle:8.5-jdk17` 이미지를 기반으로 소스 코드를 빌드하여 실행 가능한 `.jar` 파일을 생성합니다.
- **실행 스테이지**: `eclipse-temurin:17-jre-jammy` 와 같은 가벼운 JRE(Java Runtime Environment) 이미지를 사용하여, 빌드 스테이지에서 생성된 `.jar` 파일만 복사해 실행함으로써 최종 이미지의 용량을 최소화합니다.

또한, 빌드 캐시 활용도를 높이고 불필요한 파일이 이미지에 포함되지 않도록 `.dockerignore` 파일을 작성하여 빌드 컨텍스트를 최적화했습니다.

## 2. Kubernetes 배포 리소스 구성

컨테이너화된 애플리케이션을 Kubernetes 클러스터에 배포하고 관리하기 위한 표준 리소스들을 YAML 파일로 정의했습니다. 모든 리소스는 `k8s/` 디렉토리 내에 체계적으로 구성했습니다.

- **`namespace.yaml`**: 애플리케이션 관련 리소스들을 논리적으로 격리하고 그룹화하기 위해 `eda-app` 네임스페이스를 생성했습니다.
- **`deployment.yaml`**: 애플리케이션 파드(Pod)의 상태를 관리합니다. 복제본 수(replicas), 사용할 컨테이너 이미지(`eda-app:latest`), 포트 정보 등을 정의하며, 파드가 비정상 종료 시 자동으로 복구하는 역할을 합니다.
- **`service.yaml`**: 외부 또는 클러스터 내부에서 애플리케이션에 접근할 수 있도록 고유한 네트워크 엔드포인트를 제공합니다. 개발 및 테스트 환경의 편의성을 위해 `NodePort` 타입을 사용하여 각 노드의 특정 포트를 통해 애플리케이션에 접근할 수 있도록 설정했습니다.

## 3. 빌드/배포 자동화 스크립트

개발 과정에서 반복적으로 수행되는 빌드, 배포, 환경 설정 등의 작업을 자동화하기 위해 쉘 스크립트를 작성하고 `scripts/` 디렉토리 안에 통합했습니다.

- **`scripts/build.sh`**: 소스 코드를 빌드하고 새로운 Docker 이미지를 생성합니다.
- **`scripts/deploy.sh`**: `k8s/`의 리소스들을 클러스터에 적용(`apply`)하고, `kubectl rollout restart` 명령을 통해 새로운 이미지가 즉시 배포되도록 파드를 재시작합니다.
- **`scripts/teardown.sh`**: 배포된 모든 Kubernetes 리소스를 한 번에 삭제하여 환경을 정리합니다.
- **`scripts/run-db.sh`**: `docker-compose`를 사용하여 로컬 개발용 데이터베이스 컨테이너를 실행합니다.
- **`scripts/stop-db.sh`**: 실행 중인 로컬 데이터베이스 컨테이너를 중지하고 삭제합니다.

모든 스크립트는 실행되는 위치에 관계없이 항상 올바르게 동작하도록 파일 경로를 명확하게 지정하여 견고성을 확보했습니다.

## 결과

이를 통해 **소스 코드 변경부터 Kubernetes 클러스터에 배포하기까지의 전 과정**이 표준화되고 자동화되었습니다. 이제 개발자는 간단한 스크립트 실행만으로 애플리케이션을 빌드하고 배포할 수 있게 되어, 개발 생산성과 운영 안정성이 크게 향상되었습니다.
