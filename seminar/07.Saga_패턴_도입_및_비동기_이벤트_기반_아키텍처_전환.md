# 07. Saga 패턴 도입 및 비동기 이벤트 기반 아키텍처 전환

본 자료는 동기식 주문 서비스의 한계를 극복하기 위해 **Saga 패턴(코레오그래피 방식)**을 도입하고, 비동기 이벤트 기반 아키텍처(EDA)로 전환한 과정을 정리합니다.

## 1. 동기식 방식의 한계와 전환 배경

### 1-1. 강한 결합도 (Tight Coupling)
- 주문 서비스가 재고와 적립금 서비스의 가용성에 직접적인 영향을 받음.
- 외부 서비스 중 하나만 장애가 나도 전체 주문 프로세스가 중단됨.

### 1-2. 실패 이력의 유실 (Visibility Issue)
- 단일 트랜잭션 내에서 `RuntimeException` 발생 시 전체가 롤백됨.
- 이로 인해 "재고 부족으로 실패한 주문" 등의 비즈니스 이력이 DB에 남지 않고 사라지는 문제 발생.

## 2. Saga 패턴 설계: 코레오그래피(Choreography) 방식

중앙 제어자 없이 각 서비스가 이벤트를 구독하고 발행하며 자율적으로 흐름을 이어가는 방식을 채택했습니다.

### 2-1. 이벤트 라이프사이클 (Happy Path)
1. **OrderService:** 주문 `PENDING` 저장 → `OrderCreatedEvent` 발행.
2. **StockService:** `OrderCreatedEvent` 구독 → 재고 차감 → `StockDeductedEvent` 발행.
3. **PointService:** `StockDeductedEvent` 구독 → 적립금 차감 → `PointDeductedEvent` 발행.
4. **OrderService:** `PointDeductedEvent` 구독 → 주문 상태를 `COMPLETED`로 업데이트.

### 2-2. 보상 트랜잭션 (Compensation)
- 중간 단계(재고 부족, 적립금 부족 등)에서 실패 이벤트(`StockFailedEvent`, `PointFailedEvent`)가 발생하면, `OrderService`가 이를 구독하여 주문 상태를 **`CANCELLED`**로 변경함으로써 최종 일관성(Eventual Consistency)을 확보합니다.

## 3. 핵심 기술적 해결 사항

### 3-1. 트랜잭션 격리와 데이터 가시성 해결
- **문제:** 주문 생성 트랜잭션이 commit되기 전에 리스너가 실행되어 DB에서 주문을 조회하지 못하는 현상 발생.
- **해결:** `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`를 사용하여 원본 트랜잭션이 commit된 후에만 이벤트를 처리하도록 보장했습니다.
- **독립 트랜잭션:** 각 리스너는 `Propagation.REQUIRES_NEW`를 사용하여 자신만의 독립적인 트랜잭션 범위를 갖도록 설계했습니다.

### 3-2. 서비스 간 느슨한 결합 (Decoupling)
- `OrderService`는 더 이상 `DeductStockPort`, `DeductPointPort`를 직접 의존하지 않습니다.
- 오직 `ApplicationEventPublisher`를 통해 이벤트를 던지는 역할만 수행하며, 각 서비스는 리스너(`EventListener`)를 통해 독립적으로 동작합니다.

## 4. 전환 후의 기대 효과

1. **시스템 가용성 증대:** 특정 서비스의 일시적 장애가 전체 시스템의 중단으로 이어지지 않습니다.
2. **비즈니스 가시성 확보:** 실패한 주문도 `CANCELLED` 상태로 DB에 기록되어, 운영팀에서 실패 원인을 분석하고 추적할 수 있습니다.
3. **확장성 용이:** 배송 서비스, 알림 서비스 등을 추가할 때 기존 코드를 수정하지 않고 새로운 이벤트 리스너만 추가하면 됩니다.

## 5. 향후 과제

현재는 Spring 내부 이벤트를 사용하고 있어 단일 JVM 내에서만 비동기가 동작합니다. 다음 단계에서는 이를 **Kafka**와 같은 외부 메시지 브로커로 교체하여, 실제 물리적으로 분산된 마이크로서비스 환경에서도 동일한 Saga 패턴이 동작하도록 확장할 예정입니다.
