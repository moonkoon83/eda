# 05. Kustomize를 이용한 다중 환경 관리

이전 단계에서 구축한 컨테이너 배포 환경을 한 단계 발전시켜, 여러 환경(`local`, `develop`, `master`)을 체계적으로 관리하고, 실제 운영에 가까운 구성을 적용하는 고도화 작업을 진행했습니다. 이 과정에서 Kubernetes 네이티브 설정 관리 도구인 **`Kustomize`**를 도입했습니다.

## 1. Kustomize 도입 및 폴더 구조화

여러 환경에 걸쳐 중복되는 설정을 최소화하고, 각 환경의 차이점만 효율적으로 관리하기 위해 `k8s` 디렉토리를 `Kustomize` 표준 구조로 재구성했습니다.

```
k8s/
├── base/              # 모든 환경의 공통 설정 (템플릿 역할)
│   ├── deployment.yaml
│   ├── service.yaml
│   └── kustomization.yaml
├── develop/           # 개발 환경 전용 설정 (Overlay)
├── local/             # 로컬 환경 전용 설정 (Overlay)
└── master/            # 운영 환경 전용 설정 (Overlay)
```

- **`base`**: 모든 환경이 공통으로 사용할 리소스의 원본을 정의합니다. 네임스페이스와 같이 환경에 따라 변하는 값은 비워둡니다.
- **`overlays` (`local`, `develop`, `master`)**: 각 환경의 `kustomization.yaml` 파일에서 `base`를 상속받은 뒤, 해당 환경에 필요한 '차이점'(예: 네임스페이스, ConfigMap 값 등)만을 정의합니다.

## 2. ConfigMap을 통한 동적 설정 주입

환경별로 달라지는 설정을 이미지에 직접 구워 넣거나 `Deployment` 파일에 하드코딩하는 대신, `ConfigMap`을 사용하여 외부에서 동적으로 주입하는 방식으로 변경했습니다.

- **`deployment.yaml` 수정**: `base`의 `deployment.yaml`에는 `SPRING_PROFILES_ACTIVE`와 `DB_HOST` 같은 환경 변수를 `ConfigMap`에서 가져오도록 `valueFrom.configMapKeyRef`를 사용해 설정했습니다.
- **`kustomization.yaml` 수정**: 각 `overlay`의 `kustomization.yaml`에서는 `configMapGenerator`를 사용하여 해당 환경에 맞는 `SPRING_PROFILES_ACTIVE`와 `DB_HOST` 값을 가진 `ConfigMap`을 동적으로 생성하도록 했습니다.
- **결과**: `deploy.sh` 실행 시, `Kustomize`는 각 환경에 맞는 `ConfigMap`을 생성하고, `Deployment`는 이 `ConfigMap`을 참조하여 파드의 환경 변수를 설정합니다. 이를 통해 설정과 애플리케이션의 관심사를 완벽하게 분리했습니다.

## 3. 네트워크 문제 해결 및 서비스 노출 방식 개선

초기 설정 과정에서 발생했던 다양한 네트워크 문제를 진단하고 해결했습니다.

1.  **DB 연결 오류 (`Connection Refused`) 해결**:
    - **원인**: 파드 내부의 `localhost`는 파드 자신을 가리키므로, 클러스터 외부(호스트 PC)의 DB에 접속하지 못하는 문제였습니다.
    - **해결**: `DB_HOST` 환경 변수를 도입하고, Kubernetes 배포 시에는 `host.docker.internal` 값을 주입하여 파드가 호스트 PC의 DB를 찾을 수 있도록 수정했습니다.

2.  **`NodePort` 접속 불가 오류 해결**:
    - **원인**: `base` 리소스에 `namespace`가 하드코딩되어, `Kustomize`가 환경별 네임스페이스를 제대로 적용하지 못했습니다. 이로 인해 서비스와 파드가 서로 다른 네임스페이스에 생성되어 연결되지 못했습니다.
    - **해결**: `base` 리소스에서 하드코딩된 `namespace`를 제거하여, `Kustomize`가 각 `overlay`에 정의된 네임스페이스를 올바르게 주입하도록 수정했습니다.

3.  **서비스 노출 방식 변경 (`NodePort` → `LoadBalancer`)**:
    - 로컬 환경에서의 접속 편의성을 높이기 위해 서비스 타입을 `LoadBalancer`로 변경했습니다. 이를 통해 Docker Desktop 환경에서는 `localhost`로, Minikube에서는 `minikube tunnel`을 통해 안정적인 외부 IP로 서비스에 접속할 수 있게 되었습니다.

4.  **접속 스크립트 추가 (`start-access.sh`, `stop-access.sh`)**:
    - `LoadBalancer` 방식 외에, 필요시 `kubectl port-forward`를 백그라운드에서 편리하게 사용하고 종료할 수 있는 스크립트 한 쌍을 추가하여 선택지를 넓혔습니다.

## 4. 차세대 운영 환경 고려 (Gateway API)

실제 운영 환경에서의 트래픽 관리에 대해 논의하며, 기존 `Ingress`의 단점을 보완하는 차세대 표준인 **`Gateway API`**가 현대적인 Kubernetes 환경에서 가장 권장되는 방식임을 확인했습니다. 이는 향후 아키텍처 발전에 고려해 볼 중요한 사항입니다.

## 결론

`Kustomize`와 `ConfigMap`을 중심으로 Kubernetes 설정을 재구성함으로써, 각 환경의 독립성을 보장하고, 설정 변경을 유연하고 안전하게 관리할 수 있는 기반을 마련했습니다. 또한, 다양한 네트워크 문제 해결 과정을 통해 쿠버네티스 네트워킹에 대한 깊은 이해를 얻을 수 있었습니다.
