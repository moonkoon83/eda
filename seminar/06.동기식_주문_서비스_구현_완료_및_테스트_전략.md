# 06. 동기식 주문 서비스 구현 완료 및 테스트 전략

본 자료는 헥사고날 아키텍처를 기반으로 구현된 **동기식(Synchronous) 주문 서비스**의 구현 결과와 코드 품질을 높이기 위한 리팩토링 과정, 그리고 테스트 전략을 정리합니다.

## 1. 구현 결과 요약

### 1-1. 서비스 아키텍처 (동기 방식)
현재 주문 서비스는 주문 생성 시 재고(Stock)와 적립금(Point) 서비스를 직접 호출(Direct Call)하는 구조입니다.

- **OrderService:** 전체 비즈니스 로직을 제어하며, `@Transactional`을 통해 원자성(Atomicity)을 보장합니다.
- **Port & Adapter:** 재고와 적립금 서비스를 호출하기 위한 인터페이스(Port)를 정의하고, 가상의 어댑터(Mock Adapter)를 통해 실제 통신을 시뮬레이션합니다.

### 1-2. 비즈니스 흐름
1.  **주문 생성 요청:** 유효성 검증이 완료된 `CreateOrderRequest`를 수신합니다.
2.  **주문 번호 생성:** 유니크한 주문 번호를 생성합니다 (`OrderNumberGenerator`).
3.  **도메인 객체 생성:** `Order.create()` 정적 팩토리 메서드를 통해 도메인 무결성을 검증하며 객체를 생성합니다.
4.  **재고 차감:** `DeductStockPort`를 통해 실시간으로 재고를 확인하고 차감합니다. (실패 시 예외 발생)
5.  **적립금 차감:** `DeductPointPort`를 통해 사용자의 적립금을 차감합니다. (실패 시 예외 발생)
6.  **상태 변경:** 모든 호출이 성공하면 주문 상태를 `COMPLETED`로 변경합니다.
7.  **데이터 저장:** 최종적으로 주문 정보를 DB(`eda_order`)에 영속화합니다.

## 2. 코드 품질을 위한 리팩토링 (Senior Level)

### 2-1. 도메인 모델의 무결성 보호 (Domain Validation)
엔티티가 생성될 때부터 항상 올바른 상태를 유지하도록 **자가 검증 로직**을 포함했습니다.

- **정적 팩토리 메서드 도입:** 외부에서 `new Order()`를 통한 무분별한 생성을 막기 위해 생성자를 `private`으로 닫고, `Order.create()` 메서드만 노출했습니다.
- **내부 검증 로직:** 상품 ID 누락, 수량 0 이하 등 비정상적인 데이터가 도메인 영역으로 침투하는 것을 원천 차단했습니다.
  ```java
  // Order.java 내부 검증 예시
  private void validate(String orderNumber, String productId, Integer quantity) {
      if (productId == null || productId.isBlank()) throw new IllegalArgumentException("Product ID must not be empty.");
      if (quantity == null || quantity <= 0) throw new IllegalArgumentException("Quantity must be greater than zero.");
  }
  ```

### 2-2. API 계층의 입력값 검증 (Bean Validation)
잘못된 요청이 서비스 레이어까지 도달하지 않도록 **Spring Boot Starter Validation**을 도입했습니다.

- **DTO 검증:** `CreateOrderRequest`에 `@NotBlank`, `@Min` 등의 어노테이션을 적용했습니다.
- **컨트롤러 적용:** `@Valid` 어노테이션을 통해 HTTP 요청 바디를 바인딩하는 즉시 검증을 수행합니다.
  ```java
  public ResponseEntity<Order> createOrder(@Valid @RequestBody CreateOrderRequest request) { ... }
  ```

### 2-3. 데이터베이스 예약어 충돌 해결
- **문제:** H2 및 MySQL에서 `orders`는 표준 예약어로 분류되어 `SQLGrammarException`을 유발했습니다.
- **해결:** 엔티티 테이블 이름을 `eda_order`로 변경하여 모든 환경에서 안정적으로 동작하도록 수정했습니다. 실무에서도 `order`, `user`, `group` 등은 테이블 명으로 피하는 것이 관례입니다.

## 3. 테스트 전략

### 3-1. 단위 테스트 (Unit Test)
- **대상:** `OrderService`, `OrderNumberGenerator` 등 개별 클래스.
- **방법:** Mockito를 사용하여 외부 의존성(Port)을 Mocking하고 순수 비즈니스 로직만 검증합니다.
- **특징:** 재고 부족(`StockShortageException`) 등의 예외 시나리오를 즉각적으로 테스트할 수 있습니다.

### 3-2. 통합 테스트 (Integration Test)
- **대상:** API 컨트롤러부터 실제 DB 저장까지의 전체 흐름.
- **방법:** `@SpringBootTest`와 `@ActiveProfiles("local")`을 사용하여 실제 MySQL 환경에서 테스트합니다.
- **특징:** 트랜잭션 롤백(@Transactional)을 통해 테스트 데이터가 DB에 남지 않도록 관리하며, 실제 DB 제약 조건(Unique Key 등)까지 검증합니다.

## 4. 향후 과제: EDA로의 전환

현재의 동기 방식은 시스템 간의 **강한 결합도**로 인해 한 서비스의 장애가 전체로 전파될 위험이 있습니다. 이를 해결하기 위해 다음 단계에서는 **Saga 패턴**을 도입하여, 메시지 브로커(Kafka 등)를 통한 비동기 처리 구조로 전환할 예정입니다.
