# 09. 병렬적 코레오그래피 Saga 구현 및 상태 관리 전략

본 자료는 비동기 이벤트 시스템에서 성능을 최적화하기 위해 도입한 **병렬적 코레오그래피(Parallel Choreography)**의 구현 방식과, 흩어진 서비스 결과를 취합하는 상태 관리 전략을 정리합니다.

## 1. 병렬적 코레오그래피란?

순차적 방식이 앞 단계의 성공 소식을 기다려야 하는 것과 달리, **모든 참여 서비스가 첫 번째 이벤트(OrderCreated)를 수신하자마자 동시에 작업을 시작**하는 방식입니다.

### ⚡ 시스템 흐름도
1.  **주문 서비스:** `OrderCreatedEvent` 발행.
2.  **재고 & 적립금 서비스:** `OrderCreatedEvent`를 동시에 수신하여 병렬로 처리 시작.
3.  **결과 수집:** 각 서비스는 작업 완료 시 독립적으로 `StockDeductedEvent`, `PointDeductedEvent` 발행.
4.  **최종 완료:** 주문 서비스가 두 소식을 모두 수신한 시점에 `COMPLETED` 상태로 변경.

## 2. 핵심 구현 매커니즘: Join & State Management

병렬 구조에서는 "누가 마지막 주자인지" 알 수 없기 때문에, 주문 엔티티가 각 서비스의 성공 여부를 직접 관리해야 합니다.

### 2-1. 도메인 엔티티의 상태 확장 (Order.java)
주문 엔티티에 각 단계별 성공 여부를 기록하는 플래그를 추가하고, 상태 전이를 내부에서 결정하게 합니다.
```java
public class Order {
    private boolean isStockDeducted = false;
    private boolean isPointDeducted = false;

    public void completeStock() {
        this.isStockDeducted = true;
        checkCompletion();
    }

    public void completePoint() {
        this.isPointDeducted = true;
        checkCompletion();
    }

    private void checkCompletion() {
        if (isStockDeducted && isPointDeducted) {
            this.status = OrderStatus.COMPLETED;
        }
    }
}
```

### 2-2. 이벤트 구독 병렬화
`PointEventListener`가 `StockDeductedEvent`를 기다리는 대신 `OrderCreatedEvent`를 직접 구독하도록 수정했습니다.
```java
// PointEventListener.java
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void onOrderCreated(OrderCreatedEvent event) {
    // 이제 재고 성공 소식을 기다리지 않고 바로 포인트 차감 실행!
}
```

## 3. 병렬 구조의 장단점 분석

### 장점 (Pros)
- **성능(Latency) 최적화:** 전체 주문 처리 시간이 각 서비스 소요 시간의 합계가 아닌, 가장 오래 걸리는 서비스의 소요 시간으로 수렴합니다.
- **서비스 독립성:** 각 서비스 간의 논리적 선후 관계를 제거하여 진정한 비동기 자율성을 확보합니다.

### 단점 (Cons)
- **상태 관리 복잡도:** 주문 엔티티가 "어디까지 완료되었는지"에 대한 세밀한 상태를 추적해야 합니다.
- **복잡한 보상 트랜잭션:** 한쪽은 성공하고 한쪽은 실패했을 때, 성공한 쪽을 다시 복구하는 흐름이 거미줄처럼 복잡해질 수 있습니다.

## 4. 실무적 조언: 언제 병렬 구조를 선택하나?

1.  **독립적인 Side-effect:** 이메일 발송, 푸시 알림, 데이터 분석 적재 등 서로 영향을 주지 않는 작업들은 무조건 병렬로 처리합니다.
2.  **초고속 응답 필요 시:** 고객에게 "주문 접수 완료" 페이지를 보여주기까지의 시간을 최소화해야 할 때 핵심 로직 일부를 병렬화합니다.
3.  **데이터 정합성이 최우선일 때:** 재고-결제와 같이 돈과 물건이 얽힌 로직은 가급적 **순차적 구조**를 유지하여 시스템의 안정성을 확보한 뒤, 충분한 검증을 거쳐 병렬화를 시도하는 것이 안전합니다.

## 5. 결론

병렬적 코레오그래피는 시스템의 성능을 비약적으로 향상시킬 수 있는 강력한 무기입니다. 하지만 그만큼 **정교한 엔티티 상태 설계**와 **예외 상황에 대한 대비**가 수반되어야 합니다. 현재 우리 프로젝트는 이 두 마리 토끼를 모두 잡는 설계를 통해 성공적으로 병렬 전환을 완료했습니다.
