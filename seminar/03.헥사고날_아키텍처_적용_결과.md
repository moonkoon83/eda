## 세미나: 실전! 헥사고날 아키텍처 리팩토링 결과 공유

**발표자:** Gemini
**날짜:** 2026-02-03

---

### 1. 왜 헥사고날 아키텍처를 도입했는가? (Recap)

이전 세션에서 논의했듯이, 저희는 장기적인 **유지보수성, 테스트 용이성, 유연성**을 확보하기 위해 헥사고날 아키텍처 도입을 결정했습니다.

목표는 단 하나, **"애플리케이션의 핵심 비즈니스 로직을 외부 세계의 변화로부터 보호하는 것"** 입니다.

---

### 2. 무엇이, 어떻게 바뀌었는가? (Before & After)

가장 큰 변화는 **패키지 구조**와 **의존성의 방향**입니다.

*   **Before (일반적인 계층형 아키텍처):** `controller`, `service`, `repository` 등 기술 중심의 패키지 구조. 서비스가 리포지토리에 직접 의존.
*   **After (헥사고날 아키텍처):** `domain`, `application`, `adapter` 등 역할 중심의 패키지 구조. 모든 의존성이 `application`의 `port`(인터페이스)를 향함.

---

### 3. 새로운 아키텍처 상세 분석

#### 가. 패키지별 역할

*   `com.pulmuone.eda.domain`
    *   **역할:** 프로젝트의 가장 핵심. 순수한 비즈니스 데이터와 규칙을 담는 도메인 객체가 위치합니다.
    *   **특징:** **외부 프레임워크(Spring, JPA 등)에 대한 의존성이 전혀 없습니다.** 오직 순수 Java 코드로만 구성됩니다.
    *   **포함된 클래스:** `Order`, `OrderStatus`

*   `com.pulmuone.eda.application`
    *   **역할:** 애플리케이션의 핵심 비즈니스 로직(유스케이스)을 정의하고 구현합니다.
    *   `port.in`: 외부에서 애플리케이션을 사용하기 위한 진입점(창구) 역할을 하는 **인터페이스**입니다. (e.g., `CreateOrderUseCase`)
    *   `port.out`: 애플리케이션이 DB 저장, 외부 API 호출 등 외부 기능을 사용하기 위한 **인터페이스**입니다. (e.g., `SaveOrderPort`, `LoadOrderPort`)
    *   `service`: `port.in` 인터페이스의 **구현체**입니다. 비즈니스 흐름을 관장하며, 다른 `port.out` 인터페이스들을 호출합니다. (e.g., `OrderService`)

*   `com.pulmuone.eda.adapter`
    *   **역할:** 외부 세계와의 '연결'을 담당하는 구현 기술들이 위치합니다.
    *   `in.web`: 외부(웹)의 요청을 받아 `port.in` 인터페이스를 호출하는 **어댑터**입니다. (e.g., `OrderController`)
    *   `out.persistence`: `port.out` 인터페이스의 요구사항을 JPA와 같은 특정 DB 기술로 구현하는 **어댑터**입니다. (e.g., `OrderPersistenceAdapter`)

#### 나. 주요 클래스별 기능

*   `OrderController` (**Primary Adapter**):
    *   **기능:** HTTP 요청을 애플리케이션이 이해할 수 있는 메소드 호출로 변환하고, 그 결과를 다시 HTTP 응답으로 변환합니다.
    *   **의존성:** 오직 `CreateOrderUseCase` (Inbound Port) 인터페이스에만 의존합니다. `OrderService` 라는 구체적인 클래스의 존재는 알지 못합니다.

*   `CreateOrderUseCase` (**Inbound Port**):
    *   **기능:** "주문을 생성한다"는 애플리케이션의 유스케이스(기능 명세)를 인터페이스로 정의합니다.

*   `OrderService` (**Use Case 구현체 / 핵심 로직**):
    *   **기능:** `CreateOrderUseCase`의 실제 구현체. 주문 생성 비즈니스 로직의 전체 흐름(주문 번호 생성 → DB 저장 요청)을 담당합니다.
    *   **의존성:** `OrderNumberGenerator` 및 `SaveOrderPort`, `LoadOrderPort` (Outbound Ports) 인터페이스에만 의존합니다. JPA나 실제 DB가 어떻게 동작하는지는 전혀 알지 못합니다.

*   `SaveOrderPort`, `LoadOrderPort` (**Outbound Ports**):
    *   **기능:** "주문을 저장해야 한다", "주문을 조회해야 한다"는 애플리케이션의 요구사항을 인터페이스로 정의합니다.

*   `OrderPersistenceAdapter` (**Secondary Adapter**):
    *   **기능:** `SaveOrderPort`와 `LoadOrderPort`가 요구한 기능을 **'JPA 기술을 사용해서'** 실제로 구현합니다. 모든 DB 관련 상세 구현은 이 클래스 안에 캡슐화됩니다.
    *   **의존성:** Spring Data JPA (`JpaRepository`) 기술에 의존합니다.

---

### 4. 테스트 전략의 변화


아키텍처 변경으로 테스트 코드가 더 명확하고 견고해졌습니다.

*   **단위 테스트 (`OrderServiceTest.java`):**
    *   이제 `OrderRepository`라는 특정 기술의 Mock 대신, `SaveOrderPort`, `LoadOrderPort`라는 **행위의 Mock**을 주입받습니다.
    *   이를 통해 `OrderService`는 DB 기술과 완전히 분리된 채 순수 비즈니스 로직만 테스트할 수 있게 되었습니다.

*   **통합 테스트 (`OrderIntegrationTest.java`):**
    *   `@SpyBean`의 deprecation 경고를 해결하기 위해, 테스트 전용 설정(`@TestConfiguration`)을 사용하여 Spy 객체를 직접 생성하고 주입하는 방식으로 리팩토링했습니다.
    *   이를 통해 특정 시나리오(주문 번호 중복)를 안정적으로 검증하면서도, 전체 애플리케이션 컨텍스트 안에서 모든 어댑터들이 올바르게 연결되어 동작하는지 확인할 수 있습니다.

---

### 4. 결과 및 다음 단계

**결과:**
저희는 이제 **고도로 모듈화되고, 테스트가 용이하며, 유연한 아키텍처**의 기반을 마련했습니다. 핵심 비즈니스 로직은 외부의 변화로부터 완벽하게 보호됩니다.

**다음 단계:**
이제 다음 작업인 **"재고/적립금 서비스 연동"** 을 진행할 차례입니다. 새로운 아키텍처 덕분에 이 작업은 매우 간단해졌습니다.

1.  `application/port/out`에 `CheckStockPort`, `UsePointPort` 인터페이스를 추가합니다.
2.  `adapter/out`에 이 포트들을 구현하는 새로운 외부 서비스 연동 어댑터를 추가하면 됩니다.
3.  핵심 로직인 `OrderService`는 오직 새로운 포트(인터페이스)에만 의존하게 되어, 외부 서비스의 실제 구현 방식과 완전히 분리된 상태를 유지할 수 있습니다.
