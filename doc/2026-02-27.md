# 2026년 2월 27일

## 작업 요약 (Executive Summary)
- **1단계 동기식 주문 서비스 완수:** 
  - 재고/적립금 연동 및 동기식 트랜잭션(롤백 포함) 구현 완료.
  - 도메인 무결성(Validation, Static Factory) 및 API 입력 검증 적용.
  - 실제 MySQL(`local` 프로필) 기반 통합 테스트 성공.
- **2단계 비동기 코레오그래피 Saga 구현 성공:**
  - `OrderCreatedEvent` -> `StockDeductedEvent` -> `PointDeductedEvent` 체인 구축.
  - `@TransactionalEventListener`와 `REQUIRES_NEW`를 적용하여 트랜잭션과 이벤트 정합성 확보.
  - 실패 시 `CANCELLED` 상태 보존을 통한 비즈니스 가시성 확보.
- **세미나 자료 작성 (3종):** 
  - `06.동기식_주문_서비스_구현_완료_및_테스트_전략.md`
  - `07.Saga_패턴_도입_및_비동기_이벤트_기반_아키텍처_전환.md`
  - `08.Saga_패턴_심화_순차_vs_병렬_구조_설계_전략.md`

## 향후 작업 계획 (To-Do List)
- [x] **1단계: 동기식 처리 방식의 주문 서비스 완성**
- [x] **2단계: Saga 패턴으로 리팩토링 (EDA 전환)**
- [ ] **3단계: Kafka 도입 및 분산 환경 구축:** 외부 메시지 브로커를 통한 실제 마이크로서비스 확장.
- [ ] **4단계: Observability 설정:** 분산 트랜잭션 모니터링 및 흐름 추적.

---

## 기술적 고찰 (Deep Dive)

### 1. 비동기 환경에서의 순서 보장 (Event Chaining)
- 각 리스너가 앞 단계의 '성공 이벤트'를 자신의 '구독 이벤트'로 설정함으로써 논리적인 실행 순서를 강제함.
- 이를 통해 중앙 관리자 없이도 분산 서비스 간의 정교한 워크플로우 제어가 가능함을 확인.

### 2. 순차적(Sequential) vs 병렬적(Parallel) 설계
- **순차적 구조:** 비즈니스 선후 관계가 명확할 때 안전하고 직관적인 구현 가능 (현재 적용 방식).
- **병렬적 구조:** 독립적인 작업들의 성능을 극대화할 수 있으나, 모든 결과의 취합(Join) 및 복잡한 보상 트랜잭션 관리가 필요함.

### 3. TransactionalEventListener의 신뢰성과 한계
- **장점:** `AFTER_COMMIT`을 통해 '유령 이벤트'를 방지하고 데이터 가시성을 확보함.
- **위험 요소:** commit 성공 후 리스너 실행 직전에 시스템 장애가 발생하면 '이벤트 유실'이 일어날 수 있음.
- **해결책:** 향후 **Transactional Outbox Pattern**을 도입하여 데이터와 이벤트를 동일 트랜잭션으로 저장하는 구조로 개선 필요.

---

## 오늘의 작업 진행 상세
1.  **동기식 연동:** `DeductStockPort`, `DeductPointPort` 인터페이스 및 어댑터 구현.
2.  **예약어 해결:** `orders` 테이블을 `eda_order`로 변경하여 H2/MySQL 충돌 해결.
3.  **코드 품질:** 정적 팩토리 메서드 및 `jakarta.validation` 도입.
4.  **비동기 전환:** `OrderService`에서 이벤트 발행으로 전환 및 각 서비스 리스너 구현.
5.  **트랜잭션 최적화:** `Propagation.REQUIRES_NEW`를 통한 독립 트랜잭션 확보 및 테스트 성공.
